#!/usr/bin/env python3
"""
Brewfile and system update manager.

Usage:
  update [--profile <profile>] [-y]          # Update system (default)
  update cleanup [--profile <profile>] [-y]  # Clean up unused packages
  update install [--profile <profile>]       # Install packages from Brewfiles
  update secrets [--profile <profile>]       # Fetch secrets from Bitwarden

Options:
  -y, --yes  Skip confirmation prompts (auto-confirm cleanup)

Profiles:
  - Loads Brewfile.common + Brewfile.<profile> from extras/
  - Default profile: reads from chezmoi config or 'home'
"""
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile
from argparse import ArgumentParser
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict

# Default directory for additional Brewfiles
EXTRAS_DIR = Path.home() / '.local' / 'share' / 'chezmoi' / 'extras'
# Chezmoi config file
CHEZMOI_CONFIG = Path.home() / '.config' / 'chezmoi' / 'chezmoi.toml'
# Secrets directory
SECRETS_DIR = Path.home() / '.config' / 'local'
# Order of sections in merged Brewfile
SECTION_ORDER = ('tap', 'brew', 'cask', 'mas')


def get_chezmoi_profile() -> str:
    """Read profile from chezmoi config file."""
    if not CHEZMOI_CONFIG.is_file():
        return 'home'
    content = CHEZMOI_CONFIG.read_text()
    match = re.search(r'^\s*profile\s*=\s*["\']?(\w+)["\']?', content, re.MULTILINE)
    return match.group(1) if match else 'home'


def fetch_secrets(profile: str = 'home') -> None:
    """Fetch secrets from Bitwarden and write attachments to secrets dir."""
    if not shutil.which("bw"):
        sys.stderr.write("Error: Bitwarden CLI not found.\n")
        sys.exit(1)

    bw_item = f"_chezmoi_{profile}"
    print(f"Fetching secrets from Bitwarden ({bw_item})...")

    # Login/unlock Bitwarden
    login_check = subprocess.run(
        ["bw", "login", "--check"],
        capture_output=True
    )

    if login_check.returncode != 0:
        result = subprocess.run(
            ["bw", "login", "--raw"],
            stdout=subprocess.PIPE,
            text=True
        )
        if result.returncode != 0:
            sys.stderr.write("Error: Bitwarden login failed.\n")
            sys.exit(1)
        bw_session = result.stdout.strip()
    else:
        result = subprocess.run(
            ["bw", "unlock", "--raw"],
            stdout=subprocess.PIPE,
            text=True
        )
        if result.returncode != 0:
            sys.stderr.write("Error: Bitwarden unlock failed.\n")
            sys.exit(1)
        bw_session = result.stdout.strip()

    env = {**os.environ, "BW_SESSION": bw_session}

    # Sync vault
    if subprocess.run(["bw", "sync"], env=env).returncode != 0:
        sys.stderr.write("Error: Bitwarden sync failed.\n")
        sys.exit(1)

    # Get item
    result = subprocess.run(
        ["bw", "get", "item", bw_item],
        env=env, capture_output=True, text=True
    )
    if result.returncode != 0:
        sys.stderr.write(f"Error: Failed to get Bitwarden item: {bw_item}\n")
        sys.exit(1)

    item = json.loads(result.stdout)
    item_id = item["id"]
    attachments = item.get("attachments", [])

    if attachments:
        SECRETS_DIR.mkdir(parents=True, exist_ok=True)
        for att in attachments:
            att_id = att["id"]
            att_name = att["fileName"]
            print(f"  Writing {att_name}...")
            subprocess.run(
                ["bw", "get", "attachment", att_id, "--itemid", item_id,
                 "--output", str(SECRETS_DIR / att_name)],
                env=env, check=True
            )
    else:
        print(f"  No attachments found on {bw_item}")

    # Lock vault
    subprocess.run(["bw", "lock"], env=env)
    print("Secrets updated.")


def get_merged_brewfile(base_dir: Optional[Path] = None, profile: str = 'home') -> Path:
    """Create a merged Brewfile from common + selected profile.

    - Always includes Brewfile.common
    - Includes Brewfile.<profile> (work or home)
    """
    base = Path(base_dir or EXTRAS_DIR).expanduser().resolve()
    # Collect candidate brewfiles
    brewfiles: List[Path] = [base / 'Brewfile.common', base / f'Brewfile.{profile}']
    temp_path = Path(tempfile.gettempdir()) / f'brewfile_merged_{os.getpid()}.brew'

    # Header
    header = [
        f"# Merged Brewfile generated on {datetime.now()}",
        "# Sources:",
        *[f"#  - {bf.name}" for bf in brewfiles if bf.exists()],
        "",
    ]

    # Collect directives
    directives: Dict[str, set] = {sec: set() for sec in SECTION_ORDER}
    for bf in brewfiles:
        if bf.is_file():
            for raw in bf.read_text().splitlines():
                line = raw.split('#', 1)[0].strip()
                if not line:
                    continue
                key = line.split(maxsplit=1)[0]
                if key in directives:
                    directives[key].add(line)

    # Write merged contents
    with temp_path.open('w') as f:
        f.write("\n".join(header) + "\n")
        for sec in SECTION_ORDER:
            lines = sorted(directives[sec])
            if lines:
                f.write("\n".join(lines) + "\n\n")

    return temp_path


def brew_cleanup(brewfiles_dir: Optional[Path] = None, profile: str = 'home', auto_confirm: bool = False) -> None:
    extras = Path(brewfiles_dir or EXTRAS_DIR)
    if not extras.is_dir():
        sys.stderr.write(f"Error: Brewfiles directory not found: {extras}\n")
        sys.exit(1)

    print("Analyzing installed packages...")
    merged = get_merged_brewfile(extras, profile=profile)
    try:
        print("Checking for packages to clean up...")
        proc = subprocess.run(
            ["brew", "bundle", "cleanup", "--file", str(merged), "--zap"],
            capture_output=True, text=True
        )
        output = proc.stdout.splitlines() + proc.stderr.splitlines()
        lines = [l for l in output if not l.startswith("Using ")]
        if lines:
            print("\n".join(lines))
        # Detect removable packages (lines starting with 'Would ')
        to_remove = [l for l in lines if l.startswith("Would ")]
        if to_remove:
            should_remove = auto_confirm or input("\nRemove these packages? [y/N] ").strip().lower().startswith('y')
            if should_remove:
                try:
                    subprocess.run(
                        ["brew", "bundle", "cleanup", "--file", str(merged), "--zap", "--force"],
                        check=True
                    )
                    print("Cleanup completed.")
                except subprocess.CalledProcessError:
                    sys.stderr.write("Error: Cleanup failed.\n")
                    sys.exit(1)
            else:
                print("Cleanup canceled.")
        else:
            print("No unused packages found.")
    finally:
        try:
            merged.unlink()
        except FileNotFoundError:
            pass


def brew_install(
    brewfiles_dir: Optional[Path] = None,
    profile: str = 'home',
    skip_update: bool = False,
) -> None:
    extras = Path(brewfiles_dir or EXTRAS_DIR)
    if not extras.is_dir():
        sys.stderr.write(f"Error: Brewfiles directory not found: {extras}\n")
        sys.exit(1)

    if skip_update:
        print("Using existing Homebrew metadata...")
    else:
        print("Updating Homebrew...")
        try:
            subprocess.run(["brew", "update"], check=True)
        except subprocess.CalledProcessError:
            sys.stderr.write("Error: Homebrew update failed.\n")
            sys.exit(1)

    print("Installing packages...")
    merged = get_merged_brewfile(extras, profile=profile)
    try:
        subprocess.run(["brew", "bundle", "--file", str(merged)], check=True)
        print("All packages installed.")
    except subprocess.CalledProcessError:
        sys.stderr.write("Error: Some packages failed to install.\n")
        sys.exit(1)
    finally:
        try:
            merged.unlink()
        except FileNotFoundError:
            pass


def update_system(profile: str = 'home') -> None:
    managers = {
        "chezmoi": shutil.which("chezmoi") and "Dotfiles",
        "brew":    shutil.which("brew") and "Homebrew",
        "apt":     shutil.which("apt") and "System",
    }
    managers = {cmd: name for cmd, name in managers.items() if name}
    if not managers:
        sys.stderr.write("Error: No supported package managers found.\n")
        sys.exit(1)

    print("Starting system update...\n")
    results: List[bool] = []
    for cmd, name in managers.items():
        print(f"Updating {name}...")
        success = True
        try:
            if cmd == "chezmoi":
                subprocess.run(["chezmoi", "update"], check=True)
            elif cmd == "brew":
                subprocess.run(["brew", "update"], check=True)
                subprocess.run(["brew", "upgrade"], check=True)
                if shutil.which("brew-cu"):
                    subprocess.run([
                        "brew", "cu", "-y", "-q", "--cleanup", "--no-brew-update"
                    ], check=True)
                brew_install(profile=profile, skip_update=True)
                brew_cleanup(profile=profile, auto_confirm=True)
                subprocess.run(["brew", "cleanup", "-s"], check=True)
            elif cmd == "apt":
                subprocess.run(["sudo", "apt", "update"], check=True)
                subprocess.run(["sudo", "apt", "dist-upgrade", "-y"], check=True)
                subprocess.run([
                    "sudo", "apt", "autoremove", "--purge", "-y"
                ], check=False)
        except Exception:
            sys.stderr.write(f"Error updating {name}.\n")
            success = False
        print()
        results.append(success)

    total, success_count = len(results), sum(results)
    if success_count == total:
        print(f"All updates ({success_count}/{total}) successful.")
    elif success_count:
        sys.stderr.write(
            f"Partial success: {success_count}/{total} updates completed.\n"
        )
        sys.exit(1)
    else:
        sys.stderr.write("Error: No updates succeeded.\n")
        sys.exit(1)


def main():
    parser = ArgumentParser(
        description="Manage Brewfiles and system updates"
    )
    # Global options
    parser.add_argument(
        "--profile",
        default=get_chezmoi_profile(),
        help="Select Brewfile profile to use (default: from chezmoi config)",
    )
    parser.add_argument(
        "-y", "--yes",
        action="store_true",
        dest="auto_confirm",
        help="Skip confirmation prompts (auto-confirm cleanup)",
    )
    sub = parser.add_subparsers(dest="command")
    sub.add_parser("cleanup", help="Clean up unused Homebrew packages")
    sub.add_parser("install", help="Install packages from Brewfiles")
    sub.add_parser("secrets", help="Fetch secrets from Bitwarden")
    args = parser.parse_args()

    if args.command == "cleanup":
        brew_cleanup(profile=args.profile, auto_confirm=args.auto_confirm)
    elif args.command == "install":
        brew_install(profile=args.profile)
    elif args.command == "secrets":
        fetch_secrets(profile=args.profile)
    else:
        update_system(profile=args.profile)


if __name__ == "__main__":
    main()
